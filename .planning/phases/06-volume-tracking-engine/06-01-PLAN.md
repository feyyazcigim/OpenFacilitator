---
phase: 06-volume-tracking-engine
plan: 01
type: execute
wave: 1
depends_on: []
files_modified:
  - packages/server/src/db/volume-aggregation.ts
  - packages/server/src/routes/rewards.ts
autonomous: true

must_haves:
  truths:
    - "Volume aggregation includes only settle transactions with success status"
    - "Self-transfers (from_address == to_address) are excluded from volume"
    - "Only verified addresses contribute to volume calculations"
    - "Volume only counts from enrollment date forward (no retroactive credit)"
    - "Facilitator owners get volume attribution via facilitator_id lookup"
    - "Unique payers tracked as COUNT(DISTINCT from_address)"
    - "Snapshot endpoint protected by CRON_SECRET header"
    - "User can retrieve their current volume via API"
  artifacts:
    - path: "packages/server/src/db/volume-aggregation.ts"
      provides: "Volume calculation functions"
      exports: ["getVolumeByAddress", "getVolumeByFacilitatorOwnership", "getUserTotalVolume", "createDailySnapshots"]
    - path: "packages/server/src/routes/rewards.ts"
      provides: "Volume API endpoints"
      contains: ["POST /snapshot", "GET /volume"]
  key_links:
    - from: "packages/server/src/db/volume-aggregation.ts"
      to: "transactions table"
      via: "SQL JOIN with reward_addresses"
      pattern: "JOIN reward_addresses ra ON"
    - from: "packages/server/src/routes/rewards.ts"
      to: "packages/server/src/db/volume-aggregation.ts"
      via: "import getUserTotalVolume"
      pattern: "import.*from.*volume-aggregation"
    - from: "packages/server/src/routes/rewards.ts"
      to: "CRON_SECRET env var"
      via: "header comparison"
      pattern: "x-cron-secret.*CRON_SECRET"
---

<objective>
Implement volume tracking engine that aggregates qualifying transaction volume for rewards program.

Purpose: Enable accurate volume calculation per user for reward distribution. This is the foundation for the rewards dashboard (Phase 8) and claims engine (Phase 10).

Output: Volume aggregation service with daily snapshot job endpoint and user volume API endpoint.
</objective>

<execution_context>
@~/.claude/get-shit-done/workflows/execute-plan.md
@~/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/06-volume-tracking-engine/06-CONTEXT.md
@.planning/phases/06-volume-tracking-engine/06-RESEARCH.md
@packages/server/src/db/volume-snapshots.ts
@packages/server/src/db/transactions.ts
@packages/server/src/db/types.ts
@packages/server/src/db/reward-addresses.ts
@packages/server/src/routes/rewards.ts
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create volume aggregation service</name>
  <files>packages/server/src/db/volume-aggregation.ts</files>
  <action>
Create new module `packages/server/src/db/volume-aggregation.ts` with the following functions:

1. `getVolumeByAddress(addressId: string, sinceDate: string)` - Returns `{ volume: string, unique_payers: number }`
   - Query transactions WHERE:
     - `t.to_address` matches reward_address.address
     - `t.type = 'settle'` AND `t.status = 'success'`
     - `t.from_address != t.to_address` (exclude self-transfers)
     - `t.created_at >= sinceDate`
     - reward_address has `verification_status = 'verified'`
   - Use `COALESCE(SUM(CAST(t.amount AS INTEGER)), 0)` for volume
   - Use `COUNT(DISTINCT t.from_address)` for unique_payers
   - Return volume as string (TEXT for precision per D-01-01-001)

2. `getVolumeByFacilitatorOwnership(userId: string, sinceDate: string)` - Returns `{ volume: string, unique_payers: number }`
   - Query transactions WHERE:
     - `t.facilitator_id` IN (SELECT id FROM facilitators WHERE owner_address = userId)
     - `t.type = 'settle'` AND `t.status = 'success'`
     - `t.from_address != t.to_address`
     - `t.created_at >= sinceDate`
   - Same return format as above

3. `getUserTotalVolume(userId: string, campaignId: string)` - Returns `{ total_volume: string, unique_payers: number, snapshot_volume: string, live_volume: string, last_snapshot_date: string | null }`
   - Get snapshot total from existing `getUserVolumeForCampaign` in volume-snapshots.ts
   - Get last snapshot date for this user/campaign
   - Calculate live delta (transactions since last snapshot)
   - Sum both address-based and facilitator-ownership-based volume (they stack per CONTEXT.md)
   - Return combined totals

4. `createDailySnapshots(campaignId: string, snapshotDate: string)` - Returns `number` (processed count)
   - Get all verified reward_addresses (excluding chain_type='facilitator' markers)
   - For each address:
     - Calculate cumulative volume from enrollment (address.created_at) to snapshotDate
     - Call existing `upsertVolumeSnapshot` from volume-snapshots.ts
   - Handle facilitator ownership separately:
     - For each facilitator marker (chain_type='facilitator'), calculate owner's volume
   - Return count of snapshots created/updated

Import patterns to follow from existing codebase:
- `import { getDatabase } from './index.js'`
- `import { upsertVolumeSnapshot, getUserVolumeForCampaign } from './volume-snapshots.js'`
- Use existing TypeScript types from types.ts

Address normalization: EVM addresses are stored lowercase, Solana preserves case (per D-01-01-002). Match transaction.to_address with exact case comparison since both are normalized on insert.
  </action>
  <verify>
Run `npx tsc --noEmit` from packages/server - no type errors.
Module exports all 4 functions.
  </verify>
  <done>
Volume aggregation module exists with getVolumeByAddress, getVolumeByFacilitatorOwnership, getUserTotalVolume, and createDailySnapshots functions. All functions compile without type errors.
  </done>
</task>

<task type="auto">
  <name>Task 2: Add snapshot job endpoint</name>
  <files>packages/server/src/routes/rewards.ts</files>
  <action>
Add POST endpoint to rewards.ts for daily snapshot job:

```typescript
/**
 * POST /snapshot
 * Create daily volume snapshots (called by external cron scheduler)
 * Requires CRON_SECRET header for authentication
 */
router.post('/snapshot', async (req: Request, res: Response) => {
  // Verify cron secret
  const cronSecret = req.headers['x-cron-secret'];
  if (!cronSecret || cronSecret !== process.env.CRON_SECRET) {
    res.status(401).json({ error: 'Unauthorized' });
    return;
  }

  // Get active campaign (for now, accept campaignId from body or use default)
  const { campaignId } = req.body;
  if (!campaignId) {
    res.json({ message: 'No campaign specified', processed: 0 });
    return;
  }

  const today = new Date().toISOString().split('T')[0]; // YYYY-MM-DD UTC
  const processed = createDailySnapshots(campaignId, today);

  res.json({
    message: 'Snapshot complete',
    processed,
    date: today,
    campaignId,
  });
});
```

Import `createDailySnapshots` from the new volume-aggregation module.

Note: This endpoint does NOT use requireAuth middleware - it uses CRON_SECRET header instead. External schedulers (Railway cron, Vercel cron, etc.) will call this endpoint with the secret.
  </action>
  <verify>
Endpoint responds to POST /api/rewards/snapshot.
Without x-cron-secret header: returns 401.
With valid header but no campaignId: returns { processed: 0 }.
  </verify>
  <done>
POST /snapshot endpoint exists in rewards router. Requires x-cron-secret header matching CRON_SECRET env var. Calls createDailySnapshots with campaign ID and today's date.
  </done>
</task>

<task type="auto">
  <name>Task 3: Add user volume API endpoint</name>
  <files>packages/server/src/routes/rewards.ts</files>
  <action>
Add GET endpoint to rewards.ts for user volume retrieval:

```typescript
/**
 * GET /volume
 * Get current user's volume for a campaign
 * Returns snapshot volume + live delta = total volume
 */
router.get('/volume', requireAuth, async (req: Request, res: Response) => {
  try {
    const userId = req.user!.id;
    const campaignId = req.query.campaignId as string;

    if (!campaignId) {
      res.status(400).json({
        error: 'Validation error',
        message: 'campaignId query parameter is required',
      });
      return;
    }

    const volumeData = getUserTotalVolume(userId, campaignId);

    res.json({
      userId,
      campaignId,
      totalVolume: volumeData.total_volume,
      uniquePayers: volumeData.unique_payers,
      snapshotVolume: volumeData.snapshot_volume,
      liveVolume: volumeData.live_volume,
      lastSnapshotDate: volumeData.last_snapshot_date,
    });
  } catch (error) {
    console.error('Error getting user volume:', error);
    res.status(500).json({
      error: 'Internal server error',
      message: 'Failed to get volume data',
    });
  }
});
```

Import `getUserTotalVolume` from volume-aggregation module.

Response format uses camelCase for API consistency with other endpoints.
  </action>
  <verify>
Endpoint responds to GET /api/rewards/volume?campaignId=xxx.
Without auth: returns 401.
With auth but no campaignId: returns 400 validation error.
With auth and campaignId: returns volume data object.
  </verify>
  <done>
GET /volume endpoint exists in rewards router. Requires auth. Returns totalVolume, uniquePayers, snapshotVolume, liveVolume, lastSnapshotDate for the specified campaign.
  </done>
</task>

</tasks>

<verification>
1. TypeScript compilation passes: `cd packages/server && npx tsc --noEmit`
2. Server starts without errors: `npm run dev` in packages/server
3. New module exists: `packages/server/src/db/volume-aggregation.ts`
4. Endpoints added to rewards router (check via code inspection)
</verification>

<success_criteria>
- [ ] VOL-01: Volume aggregation queries exist and filter for settle/success/verified only
- [ ] VOL-02: Self-transfer exclusion (`from_address != to_address`) in all volume queries
- [ ] VOL-03: unique_payers tracked via COUNT(DISTINCT from_address)
- [ ] Snapshot endpoint callable by external cron with CRON_SECRET
- [ ] Volume API returns combined snapshot + live delta totals
- [ ] All code compiles without TypeScript errors
</success_criteria>

<output>
After completion, create `.planning/phases/06-volume-tracking-engine/06-01-SUMMARY.md`
</output>
